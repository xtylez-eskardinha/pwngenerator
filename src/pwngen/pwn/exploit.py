from pwngen.pwn.debugger import Debugger, RemoteDebugger
from pwnlib.elf.elf import ELF


class Exploit(object):

    _dbg: Debugger | RemoteDebugger
    _sec: dict[str, bool | str]
    _arch: str
    _elf: ELF

    def __init__(self, bin: str, addr: str = "", port: int = -1, delay: float = 0.1):
        if addr and port > 0:
            self._dbg = RemoteDebugger(bin, addr, port, delay)
        else:
            self._dbg = Debugger(bin, delay)
        self._sec = self._dbg.checksec()
        self._arch = self._sec.get("arch", "")
        self._elf = self._dbg.get_elf()

    def _restart(self):
        self._dbg.restart()

    def search_bof(self, fn: str, send: bool, buffsize: int = 0) -> int:
        if fn not in self._dbg.get_breakpoints():
            self._dbg.set_breakpoint(fn, True)
        # self._dbg.continue_until(fn)
        if send:
            self._dbg.send_cyclic(buffsize*2)
        while self._dbg._gdb.stopped.is_set():
            self._dbg.finish_breakpoint(True)
        return self._dbg.find_cyclic_bt()
    
    def search_text(self, text: str) -> list:
        return [ hex(x) for x in self._elf.search(text.encode())]
    
    def search_symbol(self, symbol: str) -> str:
        return hex(self._elf.symbols.get(symbol, 0))
    
    def sendline(self, data: str):
        self._dbg.sendline(data.encode())

    def send(self, data: str):
        self._dbg.send(data.encode())

    def recvline(self) -> bytes:
        return self._dbg.recvline()

    def recv(self, size: int) -> bytes:
        return self._dbg.recv(size)
    
    def recvall(self) -> bytes | None:
        return self._dbg.recvall()
    

# class amd64():

#     def __init__(
#         self,
#         bin: str,
#         addr: str = "",
#         port: int = -1,
#         delay: float = 0.1,
#         *args,
#         **kwargs
#     ):
#         super().__init__(*args, **kwargs)


# class i386(Exploit):

#     def __init__():
#         super().__init__(*args, **kwargs)
